// Code generated by protoc-gen-go.
// source: acme_user.proto
// DO NOT EDIT!

/*
Package certificate is a generated protocol buffer package.

It is generated from these files:
	acme_user.proto
	ca.proto
	certificate.proto

It has these top-level messages:
	AcmeUserRegisterRequest
	AcmeUserRegisterResponse
	CACreateRequest
	CACreateResponse
	CARegisterRequest
	CARegisterResponse
	CertificateListResponse
	CertificateDescribeRequest
	CertificateDescribeResponse
	CertificateCreateRequest
	CertificateCreateResponse
	Certificate
	CertificateImportRequest
	CertificateDeleteRequest
	CertificateRenewRequest
	CertificateRenewResponse
	CertificateRevokeRequest
	CertificateDeployRequest
	DNSCheckRequest
*/
package certificate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gengo/grpc-gateway/third_party/googleapis/google/api"
import dtypes "github.com/appscode/api/dtypes"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type AcmeUserRegisterRequest struct {
	Email string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
}

func (m *AcmeUserRegisterRequest) Reset()                    { *m = AcmeUserRegisterRequest{} }
func (m *AcmeUserRegisterRequest) String() string            { return proto.CompactTextString(m) }
func (*AcmeUserRegisterRequest) ProtoMessage()               {}
func (*AcmeUserRegisterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AcmeUserRegisterResponse struct {
	Status *dtypes.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Phid   string         `protobuf:"bytes,2,opt,name=phid" json:"phid,omitempty"`
}

func (m *AcmeUserRegisterResponse) Reset()                    { *m = AcmeUserRegisterResponse{} }
func (m *AcmeUserRegisterResponse) String() string            { return proto.CompactTextString(m) }
func (*AcmeUserRegisterResponse) ProtoMessage()               {}
func (*AcmeUserRegisterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AcmeUserRegisterResponse) GetStatus() *dtypes.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func init() {
	proto.RegisterType((*AcmeUserRegisterRequest)(nil), "certificate.AcmeUserRegisterRequest")
	proto.RegisterType((*AcmeUserRegisterResponse)(nil), "certificate.AcmeUserRegisterResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for AcmeUsers service

type AcmeUsersClient interface {
	Register(ctx context.Context, in *AcmeUserRegisterRequest, opts ...grpc.CallOption) (*AcmeUserRegisterResponse, error)
}

type acmeUsersClient struct {
	cc *grpc.ClientConn
}

func NewAcmeUsersClient(cc *grpc.ClientConn) AcmeUsersClient {
	return &acmeUsersClient{cc}
}

func (c *acmeUsersClient) Register(ctx context.Context, in *AcmeUserRegisterRequest, opts ...grpc.CallOption) (*AcmeUserRegisterResponse, error) {
	out := new(AcmeUserRegisterResponse)
	err := grpc.Invoke(ctx, "/certificate.AcmeUsers/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AcmeUsers service

type AcmeUsersServer interface {
	Register(context.Context, *AcmeUserRegisterRequest) (*AcmeUserRegisterResponse, error)
}

func RegisterAcmeUsersServer(s *grpc.Server, srv AcmeUsersServer) {
	s.RegisterService(&_AcmeUsers_serviceDesc, srv)
}

func _AcmeUsers_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcmeUserRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcmeUsersServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/certificate.AcmeUsers/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcmeUsersServer).Register(ctx, req.(*AcmeUserRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AcmeUsers_serviceDesc = grpc.ServiceDesc{
	ServiceName: "certificate.AcmeUsers",
	HandlerType: (*AcmeUsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AcmeUsers_Register_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 241 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x4f, 0x4c, 0xce, 0x4d,
	0x8d, 0x2f, 0x2d, 0x4e, 0x2d, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x4e, 0x4e, 0x2d,
	0x2a, 0xc9, 0x4c, 0xcb, 0x4c, 0x4e, 0x2c, 0x49, 0x95, 0x92, 0x49, 0xcf, 0xcf, 0x4f, 0xcf, 0x49,
	0xd5, 0x4f, 0x2c, 0xc8, 0xd4, 0x4f, 0xcc, 0xcb, 0xcb, 0x2f, 0x49, 0x2c, 0xc9, 0xcc, 0xcf, 0x2b,
	0x86, 0x28, 0x95, 0x12, 0x03, 0x09, 0xa7, 0x94, 0x54, 0x16, 0xa4, 0x16, 0xeb, 0x83, 0x49, 0x88,
	0xb8, 0x92, 0x3e, 0x97, 0xb8, 0x23, 0xd0, 0xd4, 0x50, 0xa0, 0xa1, 0x41, 0xa9, 0xe9, 0x99, 0xc5,
	0x25, 0x20, 0xba, 0xb0, 0x34, 0xb5, 0xb8, 0x44, 0x48, 0x84, 0x8b, 0x35, 0x35, 0x37, 0x31, 0x33,
	0x47, 0x82, 0x51, 0x81, 0x51, 0x83, 0x33, 0x08, 0xc2, 0x51, 0x0a, 0xe3, 0x92, 0xc0, 0xd4, 0x50,
	0x5c, 0x00, 0xb4, 0x29, 0x55, 0x48, 0x8d, 0x8b, 0xad, 0x18, 0x68, 0x6d, 0x69, 0x31, 0x58, 0x0b,
	0xb7, 0x11, 0x9f, 0x1e, 0xc4, 0x46, 0xbd, 0x60, 0xb0, 0x68, 0x10, 0x54, 0x56, 0x48, 0x88, 0x8b,
	0xa5, 0x20, 0x23, 0x33, 0x45, 0x82, 0x09, 0x6c, 0x30, 0x98, 0x6d, 0x54, 0xc5, 0xc5, 0x09, 0x33,
	0xb7, 0x58, 0x28, 0x97, 0x8b, 0x03, 0x66, 0xb8, 0x90, 0x8a, 0x1e, 0x92, 0x2f, 0xf5, 0x70, 0x38,
	0x56, 0x4a, 0x95, 0x80, 0x2a, 0x88, 0x0b, 0x95, 0x44, 0x9a, 0x2e, 0x3f, 0x99, 0xcc, 0xc4, 0x27,
	0xc5, 0xa3, 0x5f, 0x5c, 0x9c, 0xa3, 0x9f, 0x9c, 0xa8, 0x5f, 0x66, 0xa0, 0x67, 0x98, 0xc4, 0x06,
	0x0e, 0x0b, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0xca, 0xa1, 0xfd, 0x55, 0x61, 0x01, 0x00,
	0x00,
}
