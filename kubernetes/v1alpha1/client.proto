syntax = "proto3";

package appscode.kubernetes.v1alpha1;

option go_package = "v1alpha1";

option java_multiple_files = true;
option java_outer_classname = "ClientProto";
option java_package = "com.appscode.api.kubernetes.v1alpha1";

import "google/api/annotations.proto";
import "appscode/api/annotations.proto";
import "appscode.com/api/dtypes/types.proto";
import "k8s.io/api/core/v1/generated.proto";

service Clients {
  rpc List(ListResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DescribeResourceRequest) returns (DescribeResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(CreateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DeleteResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Update(UpdateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/{name}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Copy(CopyResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1alpha1/actions/copy/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  // Followings are type specific actions api, that can be applied upon fixed resources.
  rpc EditConfigMap(ConfigMapEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc EditSecret(SecretEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/namespaces/{namespace}/secrets/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolume(PersistentVolumeRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/persistentvolumes/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolume(PersistentVolumeUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/persistentvolumes/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolumeClaim(PersistentVolumeClaimRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/persistentvolumeclaims/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolumeClaim(PersistentVolumeClaimUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/persistentvolumeclaims/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc ReverseIndex(ReverseIndexResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1alpha1/clusters/{cluster}/{type}/{name}/reverse/{targetType}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

service Disks {
  rpc List(DiskListRequest) returns (DiskListResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1alpha1/disks/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DiskDescribeRequest) returns (DiskDescribeResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1alpha1/disks/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(DiskCreateRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/cloud/v1alpha1/disks/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DiskDeleteRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/cloud/v1alpha1/disks/{uid}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

message ListResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string api_version = 4;
  bool include_metrics = 5;
  // map type is not supported by grpc-gateway as query params.
  // https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/query.go#L57
  // https://github.com/grpc-ecosystem/grpc-gateway/issues/316
  // map<string, string> label_selector = 6;
  // example label_selector=environment=production,tier=frontend
  string selector = 6;
  string fieldSelector = 7;
}

message ReverseIndexResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 3;
  string namespace = 4;
  string api_version = 5;
  string targetType = 7;
}

message ListResourceResponse {
  KubeResourceList resources = 1;
}

message DescribeResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string raw = 5;
  bool include_metrics = 6;
  string api_version = 7;
}

message DescribeResourceResponse {
  KubeResource resource = 1;
}

message UpdateResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 3;
  Raw raw = 4;
}

message ConfigMapEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string> add = 4;
  map<string, string> update = 5;
  repeated string deleted = 6;
}

message SecretEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string>  add = 4;
  map<string, string>  update = 5;
  repeated string deleted = 6;
}

message CopyResourceRequest {
  KubeObject source = 1;
  KubeObject destination = 2;
  string api_version = 3;
}

message CreateResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 4;
  Raw raw = 5;
}

message DeleteResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string api_version = 5;
}

message GroupVersionResource {
  string group = 1;
  string version = 2;
  string resource = 3;
}

message KubeResourceList {
  GroupVersionResource gvr = 1; // plural
  string kind = 2;
  oneof  resource {
    Certificates certificates = 3;
    ClusterAlerts clusteralerts = 4;
    ClusterRoleBindings clusterrolebindings = 5;
    ClusterRoles clusterroles = 6;
    ConfigMaps configmaps = 7;
    CronJobs cronjobs = 8;
    DaemonSets daemonsets = 9;
    Deployments deployments = 10;
    DormantDatabases dormantdatabases = 11;
    Elasticsearches elasticsearches = 12;
    Events events = 13;
    Ingresses ingresses = 14;
    Jobs jobs = 15;
    Memcacheds memcacheds = 16;
    Mongodbs mongodbs = 17;
    Mysqls mysqls = 18;
    Namespaces namespaces = 19;
    NodeAlerts nodealerts = 20;
    Nodes nodes = 21;
    PersistentVolumeClaims persistentvolumeclaims = 22;
    PersistentVolumes persistentvolumes = 23;
    PodAlerts podalerts = 24;
    Pods pods = 25;
    Postgreses postgreses = 26;
    Prometheuses prometheuses = 27;
    Recoveries recoveries = 28;
    Redises redises = 29;
    ReplicaSets replicasets = 30;
    ReplicationControllers replicationcontrollers = 31;
    Repositories repositories = 32;
    Restics restics = 33;
    RoleBindings rolebindings = 34;
    Roles roles = 35;
    Secrets secrets = 36;
    ServiceMonitors servicemonitors = 37;
    Services services = 38;
    Snapshots snapshots = 39;
    StatefulSets statefulsets = 40;
    StorageClasses storageclasses = 41;
  }

  message Events {
    repeated Event items = 1;
  }

  message ConfigMaps {
    repeated ConfigMap items = 1;
  }

  message DaemonSets {
    repeated DaemonSet items = 1;
  }

  message Deployments {
    repeated Deployment items = 1;
  }

  message Jobs {
    repeated Job items = 1;
  }

  message Namespaces {
    repeated Namespace items = 1;
  }

  message Nodes {
    repeated Node items = 1;
  }

  message StatefulSets {
    repeated StatefulSet items = 1;
  }

  message Pods {
    repeated Pod items = 1;
  }

  message ReplicaSets {
    repeated ReplicaSet items = 1;
  }

  message Services {
    repeated Service items = 1;
  }

  message Secrets {
    repeated Secret items = 1;
  }

  message ReplicationControllers {
    repeated ReplicationController items = 1;
  }

  message StorageClasses {
    repeated StorageClass items = 1;
  }

  message PersistentVolumes {
    repeated PersistentVolume items = 1;
  }

  message PersistentVolumeClaims {
    repeated PersistentVolumeClaim items = 1;
  }

  message ClusterAlerts {
    repeated ClusterAlert items = 1;
  }

  message NodeAlerts {
    repeated NodeAlert items = 1;
  }

  message PodAlerts {
    repeated PodAlert items = 1;
  }

  message Roles {
    repeated Role items = 1;
  }

  message ClusterRoles {
    repeated ClusterRole items = 1;
  }

  message RoleBindings {
    repeated RoleBinding items = 1;
  }

  message ClusterRoleBindings {
    repeated ClusterRoleBinding items = 1;
  }

  message Certificates {
    repeated Certificate items = 1;
  }

  message CronJobs {
    repeated CronJob items = 1;
  }

  message Postgreses {
    repeated Postgres items = 1;
  }

  message Elasticsearches {
    repeated Elasticsearch items = 1;
  }

  message DormantDatabases {
    repeated DormantDatabase items = 1;
  }

  message Mysqls {
    repeated Mysql items = 1;
  }

  message Redises {
    repeated Redis items = 1;
  }

  message Mongodbs {
    repeated Mongodb items = 1;
  }

  message Memcacheds {
    repeated Memcached items = 1;
  }

  message Recoveries {
    repeated Recovery items = 1;
  }

  message Snapshots {
    repeated Snapshot items = 2;
  }

  message Repositories {
    repeated Repository items = 1;
  }

  message Restics {
    repeated Restic items = 1;
  }

  message Ingresses {
    repeated Ingress items = 1;
  }

  message Prometheuses {
    repeated Prometheus items = 1;
  }

  message ServiceMonitors {
    repeated ServiceMonitor items = 1;
  }
}

message KubeResource {
  GroupVersionResource gvr = 1; // singular
  string kind = 2;
  Raw raw = 3;
  repeated Event events = 4;
  oneof  resource {
    Certificate certificate = 5;
    ClusterAlert clusteralert = 6;
    ClusterRole clusterrole = 7;
    ClusterRoleBinding clusterrolebinding = 8;
    ConfigMap configmap = 9;
    CronJob cronjob = 10;
    DaemonSet daemonset = 11;
    Deployment deployment = 12;
    DormantDatabase dormantdatabase = 13;
    Elasticsearch elasticsearch = 14;
    Ingress ingress = 15;
    Job job = 16;
    Memcached memcached = 17;
    Mongodb mongodb = 18;
    Mysql mysql = 19;
    Namespace namespace = 20;
    Node node = 21;
    NodeAlert nodealert = 22;
    PersistentVolume persistentvolume = 23;
    PersistentVolumeClaim persistentvolumeclaim = 24;
    Pod pod = 25;
    PodAlert podalert = 26;
    Postgres postgres = 27;
    Prometheus prometheus = 28;
    Recovery recovery = 29;
    Redis redis = 30;
    ReplicaSet replicaset = 31;
    ReplicationController replicationcontroller = 32;
    Repository repository = 33;
    Restic restic = 34;
    Role role = 35;
    RoleBinding rolebinding = 36;
    Secret secret = 37;
    Service service = 38;
    ServiceMonitor servicemonitor = 39;
    Snapshot snapshot = 40;
    StatefulSet statefulset = 41;
    StorageClass storageclass = 42;
  }
}

message Meta {
  string name = 1;
  string namespace = 2;
  string self_link = 3;
  string resource_version = 4;
  int64 creation_timestamp = 5;
  int64 generation = 6;
  map<string, string> labels = 7;
  map<string, string> annotations = 8;
  string uid = 9;
}

message KubeObject {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message IcingaState {
  int32 OK = 1;
  int32 Warning = 2;
  int32 Critical = 3;
  int32 Unknown = 4;
}

message PodSpec {
  repeated Volume volumes = 1;
  repeated Container containers = 2;
  map<string, string> node_selector = 3;
  string service_account_name = 4;
  string node_name = 5;
  repeated string image_pull_secrets = 6;

  message Container {
    string name  = 1;
    string image = 2;
    repeated string commands = 3;
    repeated VolumeMount volume_mounts = 4;
    repeated string args = 5;
    string working_dir = 6;
    repeated EnvVar env = 7;
  }
}

message Volume {
  string name = 1;
  k8s.io.api.core.v1.VolumeSource volumeSource = 2;
}

message VolumeMount {
  string name = 1;
  bool read_only = 2;
  string mount_path = 3;
}

message Raw {
  string format = 1;
  string data = 2;
}

message ConfigMap {
  Meta meta = 1;
  map<string, string> data = 2;
}

message Job {
  Meta meta = 1;
  string app = 2;
  JobSpec spec = 3;
  Status status = 4;

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    int32 active = 3;
    int32 succeeded = 4;
    int32 failed = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message JobSpec {
  int32 parallelism = 1;
  int32 completions = 2;
  PodSpec template = 3;
  int64 active_deadline_seconds = 4;

}

message Namespace {
  Meta meta = 1;
  Status status = 2;
  NamespaceSpec spec = 3;

  message NamespaceSpec {
    repeated string finalizers = 1;
  }

  message Status {
    string phase = 1;
  }
}

message Node {
  Meta meta = 1;
  Spec spec = 2;
  bool is_master = 3;
  NodeStatus status = 4;
  Metrics metrics = 5;

  message Spec {
    string external_id = 1;
    string provider_id = 2;
    bool unschedulable = 3;
    string podCIDR = 4;
  }

  message NodeStatus {
    Capacity capacity = 1;
    string phase = 2;
    NodeSystemInfo node_info = 3;
    Capacity allocatable = 4;
    repeated ResourceCondition conditions = 5;
    repeated NodeAddress address = 6;
    repeated ContainerImage images = 7;
    repeated string volumes_in_use = 8;
    repeated AttachedVolume volumes_attached = 9;

    message Capacity {
      int64 cpu = 1;
      int64 memory = 2;
      int64 pods = 3;
      string storage = 4;
    }

    message NodeSystemInfo {
      string machineID = 6;
      string systemUUID = 7;
      string bootID = 8;
      string kernel_version = 1;
      string os_image = 2;
      string container_runtime_version = 3;
      string kubelet_version = 4;
      string kube_proxy_version = 5;
      string operating_system = 9;
      string architecture = 10;
    }

    message NodeAddress {
      string type = 1;
      string address = 2;
    }

    message ContainerImage {
      repeated string names = 1;
      int64 size_bytes = 2;
    }

    message AttachedVolume {
      string name = 1;
      string device_path = 2;
    }
  }
}

message Pod {
  Meta meta = 1;
  string app = 2;
  PodSpec spec = 3;
  PodStatus status = 4;
  Metrics metrics = 5;

  message PodStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
    string hostIP = 4;
    string podIP = 5;
    repeated ResourceCondition conditions = 6;
    int64 start_time = 7;
    repeated Service service_info = 8;
  }
}

message PersistentVolume {
  Meta meta = 1;
  PersistentVolumeSpec spec = 2;
  PersistentVolumeStatus status = 3;

  message PersistentVolumeSpec {
    map <string, string> capacity = 1;
    repeated string access_modes = 2;
    string persistent_volume_reclaim_policy = 3;
    ObjectReference claim_ref = 4;
    k8s.io.api.core.v1.PersistentVolumeSource persistent_volume_source = 5;
  }

  message PersistentVolumeStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
  }
}

message PersistentVolumeClaim {
  Meta meta = 1;
  PersistentVolumeClaimSpec spec = 2;
  PersistentVolumeClaimStatus status = 3;

  message PersistentVolumeClaimStatus {
    string phase = 1;
    repeated string access_modes = 2;
    map <string, string> capacity = 3;
  }
}

message PersistentVolumeClaimSpec {
  string storage_class_name = 1;
  repeated string access_modes = 2;
  ResourceRequirements resources = 3;
  string volume_name = 4;

  message ResourceRequirements {
    map<string, string> limits = 1;
    map<string, string> requests = 2;
  }
}

message ObjectReference {
  string kind = 1;
  string namespace = 2;
  string name = 3;
  string uid = 4;
  string api_version = 5;
  string resource_version = 6;
}

message Service {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string type = 1;
    repeated Port ports = 2;
    string selector = 3;
    string clusterIP = 4;
    repeated string externalIPs = 5;
    string loadbalancerIP = 6;
    string external_name = 7;
    string session_affinity = 8;
    repeated string load_balancer_source_ranges = 9;

    message Port {
      string name = 1;
      string protocol = 2;
      int32 port = 3;
      string target_port = 4;
      int32 node_port = 5;
    }
  }

  message Status {
    repeated LoadBalancerIngress loadbalancer_ingresses = 1;

    message LoadBalancerIngress {
      string host_name = 1;
      string IP = 2;
    }
  }
}

message Secret {
  Meta meta = 1;
  map<string, string> data = 2;
  string type = 3;
}

message ReplicationController {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message ReplicaSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message DaemonSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string selector = 1;
    PodSpec pod_template = 2;
  }

  message Status {
    int32 current_number_scheduled = 1;
    int32 number_misscheduled = 2;
    int32 desired_number_scheduled = 3;
  }
}

message Deployment {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  DeploymentStatus status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
    int32 min_ready_seconds = 4;
    int32 revision_history_limit = 5;
    bool paused = 6;
    RollbackConfig rollback_to = 7;
    int32 progress_deadline_seconds = 8;
    DeploymentStrategy strategy = 9;

    message DeploymentStrategy {
      string type = 1;
      RollingUpdateDeployment rolling_update = 2;
    }

    message RollingUpdateDeployment {
      string max_unavailable = 1;
      string max_surge = 2;
    }

    message RollbackConfig {
      int64 revision = 1;
    }
  }

  message DeploymentStatus {
    int64 observed_generation = 1;
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message StatefulSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
    string service_name = 4;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message StorageClass {
  Meta meta = 1;
  string provisioner = 2;
  map<string, string> parameters = 3;
}

message Event {
  Meta meta = 1;
  string reason = 2;
  string message = 3;
  EventSource source = 4;
  int64 first_timestamp = 5;
  int64 last_timestamp = 6;
  int32 count = 7;
  string type = 8;
}

message EventSource {
  string component = 1;
  string host = 2;
}

message Metrics {
  repeated DataPoint cpu_usage = 1;
  repeated DataPoint memory_usage = 2;

  message DataPoint {
    int64 timestamp = 1;
    int64 value     = 2;
  }
}

message PersistentVolumeRegisterRequest {
  string cluster = 1;
  string name = 2;
  string identifier = 3;
  string plugin = 4;
  int64 size_gb = 5;
  string endpoint = 6;
}

message PersistentVolumeUnRegisterRequest {
  string cluster = 1;
  string name = 2;
}

message PersistentVolumeClaimRegisterRequest {
  string cluster = 1;
  string name = 2;
  int64 size_gb = 3;
  string namespace = 4;
}

message PersistentVolumeClaimUnRegisterRequest {
  string cluster = 1;
  string name = 2;
  string namespace = 3;
}

message ClusterAlert {
  Meta meta = 1;
  ClusterAlertSpec spec = 2;

  message ClusterAlertSpec {
    // Icinga CheckCommand name
    // Values are in
    //    any_http
    //    component_status
    //    json_path
    //    node_exists
    //    pod_exists
    //    kube_event
    //    certificate_expiry
    //    hello_icinga
    //    dig
    //    dns
    //    dummy
    //    icmp
    string check = 1;
    string check_interval = 2;
    string alert_interval = 3;
    repeated AlertReceiver receivers = 4;
    map<string, string> vars = 5;
  }
}

message NodeAlert {
  Meta meta = 1;
  NodeAlertSpec spec = 2;

  message NodeAlertSpec {
    map<string, string> selector = 1;
    string node_name = 2;
    // Icinga CheckCommand name
    // Values are in
    //    influx_query
    //    node_disk
    //    node_status
    string check = 3;
    string check_interval = 4;
    string alert_interval = 5;
    repeated AlertReceiver receivers = 6;
    map<string, string> vars = 7;
  }
}

message PodAlert {
  Meta meta = 1;
  PodAlertSpec spec = 2;

  message PodAlertSpec {
    string selector = 1;
    string pod_name = 2;
    // Icinga CheckCommand name
    // Values are in
    //    influx_query
    //    pod_status
    //    volume
    //    kube_exec
    string check = 3;
    string check_interval = 4;
    string alert_interval = 5;
    repeated AlertReceiver receivers = 6;
    map<string, string> vars = 7;
  }
}

message AlertReceiver {
  string state = 1;
  repeated string to = 2;
  string notifier = 3;
}

message Role {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message RoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message ClusterRole {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message ClusterRoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message Rule {
  repeated string verbs = 1;
  repeated string api_groups = 2;
  repeated string resources = 3;
  repeated string resource_names = 4;
  repeated string non_resource_urls = 5;
}

message Subject {
  string kind = 1;
  string api_group = 2;
  string name = 3;
  string namespace = 4;
}

message Restic {
  Meta meta = 1;
  Spec spec = 2;
  message Spec {
    string selector = 1;
    repeated FileGroup file_groups = 2;
    StashBackend backend = 3;
    string schedule = 4;
    string use_auto_prefix = 5;
    repeated VolumeMount volume_mounts = 6;
    repeated RetentionPolicy retentionPolicies = 7;
    string type = 8;

    message FileGroup {
      string path = 1;
      repeated string tags = 2;
      string retentionPolicyName = 3;
    }
    message RetentionPolicy {
      string name = 1;
      int32 keep_last = 2;
      int32 keep_hourly = 3;
      int32 keep_daily = 4;
      int32 keep_weekly = 5;
      int32 keep_monthly = 6;
      int32 keep_yearly = 7;
      repeated string keep_tags = 8;
      bool prune = 9;
      bool dry_run = 10;
    }
  }
}

message Repository {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;
  message Spec {
    StashBackend backend = 3;
  }
  message Status {
    int64 first_backup_time = 1;
    int64 last_backup_time = 2;
    int64 last_successful_backup_time = 3;
    string last_backup_duration = 4;
    int64 backup_count = 5;
  }
}

message StashBackend {
  string  storage_secret_name = 1;
  oneof storage {
    LocalSpec local = 2;
    S3Spec s3 = 3;
    GCSSpec gcs = 4;
    AzureSpec azure = 5;
    SwiftSpec swift = 6;
  }

  message LocalSpec {
    k8s.io.api.core.v1.VolumeSource volumeSource = 1;
    string mountPath = 2;
    string subPath = 3;
  }

  message S3Spec {
    string endpoint = 1;
    string bucket = 2;
    string prefix = 3;
  }

  message GCSSpec {
    string bucket = 1;
    string prefix = 2;
  }

  message AzureSpec {
    string container = 1;
    string prefix = 2;
  }

  message SwiftSpec {
    string container = 1;
    string prefix = 2;
  }
}

message CronJob {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string schedule = 1;
    int64 starting_deadline_seconds = 2;
    string concurrency_policy = 3;
    bool suspend = 4;
    JobSpec template = 5;
  }

  message Status {
    repeated ObjectReference active = 1;
    int64 last_schedule_time = 2;
  }
}

message Postgres {
  Meta meta = 1;
  PostgresSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message PostgresSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  k8s.io.api.core.v1.SecretVolumeSource database_secret = 4;
  map<string, string> node_selector = 5;
  InitSpec init = 6;
  BackupScheduleSpec backup_schedule = 7;
  bool do_not_pause = 8;
  string standbyMode = 9;
  string streamingMode = 10;
  PostgresArchiverSpec archiver = 11;
  KubemonAgentSpec monitor = 12;
  ResourceRequirements resources = 13;
  Affinity affinity = 14;
  string schedulerName = 15;
  repeated Toleration tolerations = 16;
  repeated LocalObjectReference imagePullSecrets = 17;

  message PostgresArchiverSpec {
    SnapshotStorageSpec storage = 1;
  }
}

message Elasticsearch {
  Meta meta = 1;
  ElasticsearchSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message ElasticsearchSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  map<string, string> node_selector = 4;
  InitSpec init = 5;
  BackupScheduleSpec backup_schedule = 6;
  bool do_not_pause = 7;
  ElasticsearchClusterTopology topology = 8;
  bool enableSSL = 9;
  k8s.io.api.core.v1.SecretVolumeSource certificateSecret = 10;
  k8s.io.api.core.v1.SecretVolumeSource databaseSecret = 11;
  KubemonAgentSpec monitor = 12;
  ResourceRequirements resources = 13;
  Affinity affinity = 14;
  string schedulerName = 15;
  repeated Toleration tolerations = 16;
  repeated LocalObjectReference imagePullSecrets = 17;

  message ElasticsearchClusterTopology {
    ElasticsearchNode master = 1;
    ElasticsearchNode data = 2;
    ElasticsearchNode client = 3;
  }

  message ElasticsearchNode {
    int32 replicas = 1;
    string prefix = 2;
  }
}

message DormantDatabase {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    bool wipe_out = 1;
    bool resume = 2;
    Origin origin = 3;
  }

  message Status {
    int64 creation_time = 1;
    int64 pausing_time = 2;
    int64 wipe_out_time = 3;
    string phase = 4;
    string reason = 5;
  }
}

message Mysql {
  Meta meta = 1;
  MysqlSpec spec = 2;
  Status status = 3;
  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message MysqlSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  map<string, string> node_selector = 4;
  InitSpec init = 5;
  BackupScheduleSpec backup_schedule = 6;
  bool do_not_pause = 7;
  k8s.io.api.core.v1.SecretVolumeSource databaseSecret = 8;
  KubemonAgentSpec monitor = 9;
  ResourceRequirements resources = 10;
  Affinity affinity = 11;
  string schedulerName = 12;
  repeated Toleration tolerations = 13;
  repeated LocalObjectReference imagePullSecrets = 14;
}

message Redis {
  Meta meta = 1;
  RedisSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message RedisSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  map<string, string> node_selector = 4;
  bool do_not_pause = 5;
  KubemonAgentSpec monitor = 6;
  ResourceRequirements resources = 7;
  Affinity affinity = 8;
  string schedulerName = 9;
  repeated Toleration tolerations = 10;
  repeated LocalObjectReference imagePullSecrets = 11;
}

message Mongodb {
  Meta meta = 1;
  MongodbSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message MongodbSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  map<string, string> node_selector = 4;
  InitSpec init = 5;
  BackupScheduleSpec backup_schedule = 6;
  bool do_not_pause = 7;
  k8s.io.api.core.v1.SecretVolumeSource databaseSecret = 8;
  KubemonAgentSpec monitor = 9;
  ResourceRequirements resources = 10;
  Affinity affinity = 11;
  string schedulerName = 12;
  repeated Toleration tolerations = 13;
  repeated LocalObjectReference imagePullSecrets = 14;
}

message Memcached {
  Meta meta = 1;
  MemcachedSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message MemcachedSpec {
  string version = 1;
  int32 replicas = 2;
  map<string, string> node_selector = 3;
  bool do_not_pause = 4;
  KubemonAgentSpec monitor = 5;
  ResourceRequirements resources = 6;
  Affinity affinity = 7;
  string schedulerName = 8;
  repeated Toleration tolerations = 9;
  repeated LocalObjectReference imagePullSecrets = 10;
}

message Recovery {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    StashBackend backend = 1;
    repeated string paths = 2;
    LocalTypedReference workload = 3;
    string podOrdinal = 4;
    string nodeName = 5;
    repeated LocalSpec recoveredVolumes = 6;

    message LocalTypedReference {
      string kind = 1;
      string name = 2;
      string apiVersion = 3;
    }

    message LocalSpec {
      k8s.io.api.core.v1.VolumeSource volumeSource = 1;
      string mountPath = 2;
      string subPath = 3;
    }
  }

  message Status {
    string phase = 1;
    repeated RestoreStats stats = 2;

    message RestoreStats {
      string path = 1;
      string phase = 2;
      string duration = 3;
    }
  }
}

message Origin {
  Meta meta = 1;
  Spec spec = 2;

  message Spec {
    ElasticsearchSpec elasticsearch = 1;
    PostgresSpec postgres = 2;
    MysqlSpec mysql = 3;
    MongodbSpec mongodb = 4;
    RedisSpec redis = 5;
    MemcachedSpec memcached = 6;
  }
}

message Snapshot {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string database_name = 1;
    SnapshotStorageSpec snapshot_storage_spec = 2;
    ResourceRequirements resources = 3;
  }

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    string phase = 3;
    string reason = 4;
  }
}

message InitSpec {
  ScriptSourceSpec script_source = 1;
  SnapshotSourceSpec snapshot_source = 2;
}

message ScriptSourceSpec {
  string script_path = 1;
  k8s.io.api.core.v1.VolumeSource volume_source = 2;
}

message SnapshotSourceSpec {
  string namespace = 1;
  string name = 2;
}

message BackupScheduleSpec {
  string cron_expression = 1;
  SnapshotStorageSpec snapshot_storage_spec = 2;
}

message SnapshotStorageSpec {
  string storage_secret_name = 1;
  oneof storage {
    LocalSpec local = 2;
    S3Spec s3 = 3;
    GCSSpec gcs = 4;
    AzureSpec azure = 5;
    SwiftSpec swift = 6;
  }

  message LocalSpec {
    k8s.io.api.core.v1.VolumeSource volumeSource = 1;
    string mountPath = 2;
    string subPath = 3;
  }

  message S3Spec {
    string endpoint = 1;
    string bucket = 2;
    string prefix = 3;
  }

  message GCSSpec {
    string bucket = 1;
    string prefix = 2;
  }

  message AzureSpec {
    string container = 1;
    string prefix = 2;
  }

  message SwiftSpec {
    string container = 1;
    string prefix = 2;
  }
}

message Certificate {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    // Obtain a single certificate for all the domains. The first Domain provided wiil
    // be counted as Name and other domains will be in SANs.
    repeated string domains = 1;
    string ACME_user_secret_name = 2;

    ChallengeProvider challenge_provider = 3;
    CertificateStorage storage = 4;

    message ChallengeProvider {
      HTTPChallengeProvider http = 1;
      DNSChallengeProvider dns = 2;
    }

    message HTTPChallengeProvider {
      ObjectReference ingress = 1;
    }

    message DNSChallengeProvider {
      string provider = 1;
      string credential_secret_name = 2;
    }

    message CertificateStorage {
      LocalObjectReference secret = 1;
      VaultStore vault = 2;
    }

    message VaultStore {
      string name = 1;
      string prefix = 2;
    }
  }

  message Status {
    int64 creation_time = 1;
    repeated CertificateCondition conditions = 2;
    CertificateDetails last_issued_certificate = 3;

    message ACMECertificateDetails {
      string domain = 1;
      string certURL = 2;
      string cert_stableURL = 3;
      string account_ref = 4;
    }

    message CertificateCondition {
      string type = 1;
      string reason = 2;
      string message = 3;
      int64 last_update_time = 4;
    }

    message CertificateDetails {
      string serial_number = 1;
      int64 not_before = 2;
      int64 not_after = 3;
      string cert_url = 4;
      string cert_stable_url = 5;
      string account_ref = 6;
    }
  }
}

message DiskListRequest {
  string cluster=1;
}

message DiskListResponse {
  repeated Disk disks = 1;
}

message DiskDescribeRequest {
  string cluster = 1;
  string name = 2;
  string provider = 3;
}

message DiskDescribeResponse {
  Disk disk = 1;
}

message DiskCreateRequest {
  string cluster = 1;
  string name = 2;
  string zone = 3;
  string disk_type = 4;
  int64 size_gb = 5;
}

message DiskDeleteRequest {
  string cluster = 1;
  string uid = 2;
}

message Disk {
  string name = 1;
  string id = 2;
  string provider = 3;
  int64 size_gb = 4;
  string type = 5;
  string zone = 6;
  string status = 7;
  string endpoint = 8;
  int64 iops = 9;
  PersistentVolume persistent_volume = 10;
  PersistentVolumeClaim persistent_volume_claim = 11;
}

message ResourceCondition {
  string type = 1;
  string status = 2;
  int64 last_heartbeat_time = 3;
  int64 last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// Prometheus defines a Prometheus deployment.
message Prometheus {
  Meta meta = 1;
  PrometheusSpec spec = 2;
  PrometheusStatus status = 3;

  // Specification of the desired behavior of the Prometheus cluster.
  message PrometheusSpec {
    // ServiceMonitors to be selected for target discovery.
    string service_monitor_selector = 1;
    // Version of Prometheus to be deployed.
    string version = 2;
    // When a Prometheus deployment is paused, no actions except for deletion
    // will be performed on the underlying objects.
    bool paused = 3;
    // Base image to use for a Prometheus deployment.
    string base_image = 4;
    // An optional list of references to secrets in the same namespace
    // to use for pulling prometheus and alertmanager images from registries
    repeated LocalObjectReference image_pull_secrets = 5;
    // Number of instances to deploy for a Prometheus deployment.
    int32 replicas = 6;
    // Time duration Prometheus shall retain data for.
    string retention = 7;
    // The labels to add to any time series or alerts when communicating with
    // external systems (federation, remote storage, Alertmanager).
    map<string, string> external_labels = 8;
    // The external URL the Prometheus instances will be available under. This is
    // necessary to generate correct URLs. This is necessary if Prometheus is not
    // served from root of a DNS name.
    string external_url = 9;
    // The route prefix Prometheus registers HTTP handlers for. This is useful,
    // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
    // and the actual ExternalURL is still true, but the server serves requests
    // under a different route prefix. For example for use with `kubectl proxy`.
    string route_prefix = 10;
    // A selector to select which ConfigMaps to mount for loading rule files from.
    string rule_selector = 11;
    // Define which Nodes the Pods are scheduled on.
    map<string, string> node_selector = 12;
    // ServiceAccountName is the name of the ServiceAccount to use to run the
    // Prometheus Pods.
    string service_account_name = 13;
    // Secrets is a list of Secrets in the same namespace as the Prometheus
    // object, which shall be mounted into the Prometheus Pods.
    // The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.
    // Secrets changes after initial creation of a Prometheus object are not
    // reflected in the running Pods. To change the secrets mounted into the
    // Prometheus Pods, the object must be deleted and recreated with the new list
    // of secrets.
    repeated string secrets = 14;
    // Define details regarding alerting.
    AlertSpec alerting = 15;
  }

  message PrometheusStatus {
    // Represents whether any actions on the underlaying managed objects are
    // being performed. Only delete actions will be performed.
    bool paused = 1;
    // Total number of non-terminated pods targeted by this Prometheus deployment
    // (their labels match the selector).
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
  }
}

// AlertingSpec defines parameters for alerting configuration of Prometheus servers.
message AlertSpec {
  // AlertmanagerEndpoints Prometheus should fire alerts against.
  repeated PrometheusAlertmanagerEndpoint alertmanager = 1;
}

// AlertmanagerEndpoints defines a selection of a single Endpoints object
// containing alertmanager IPs to fire alerts against.
message PrometheusAlertmanagerEndpoint {
  string namespace = 1;
  string name = 2;
  int32 port = 3;
  string scheme = 4;
  string path_prefix = 5;
}

// ServiceMonitor defines monitoring for a set of services.
message ServiceMonitor {
  Meta meta = 1;
  ServiceMonitorSpec spec = 2;

  // ServiceMonitorSpec contains specification parameters for a ServiceMonitor.
  message ServiceMonitorSpec {
    // The label to use to retrieve the job name from.
    string job_label = 1;
    repeated Endpoint endpoints = 2;
    // Selector to select Endpoints objects.
    string selector = 3;
    // Selector to select which namespaces the Endpoints objects are discovered from.
    NamespaceSelector namespace_selector = 4;
  }

  // Endpoint defines a scrapeable endpoint serving Prometheus metrics.
  message Endpoint {
    // Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
    string port = 1;
    // Name or number of the target port of the endpoint. Mutually exclusive with port.
    string target_port = 2;
    // HTTP path to scrape for metrics.
    string path = 3;
    // HTTP scheme to use for scraping.
    string scheme = 4;
    // Interval at which metrics should be scraped
    string interval = 5;
  }

  message NamespaceSelector {
    // Boolean describing whether all namespaces are selected in contrast to a
    // list restricting them.
    bool any = 1;
    // List of namespace names.
    repeated string match_names = 2;
  }
}

message ResourceRequirements {
  map<string, string> limits = 1;
  map<string, string> requests = 2;
}

message Ingress {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    HTTPIngressBackend backend = 1;
    repeated IngressTLS TLS = 2;
    repeated FrontendRule frontend_rules = 3;
    repeated IngressRule rules = 4;
    repeated string load_balancer_source_ranges = 5;
    ResourceRequirements resources = 6;
    Affinity affinity = 7;
    string scheduler_name = 8;
    repeated Toleration tolerations = 9;
    repeated LocalObjectReference imagePullSecrets = 10;
  }

  message FrontendRule {
    int32 port = 1;
    repeated string rules = 2;
    AuthOption auth = 3;
  }

  message HTTPIngressBackend {
    repeated string host_names = 1;
    string service_name = 2;
    int32 service_port = 3;
    repeated string backend_rule = 4;
    repeated string rewrite_rule = 5 [deprecated=true];
    repeated string header_rule = 6 [deprecated=true];
  }

  message Status {
    repeated LoadBalancerIngress load_balancer = 1;
  }

  message LoadBalancerIngress {
    string host_name = 1;
    string IP = 2;
  }

  message IngressTLS {
    repeated string hosts = 1;
    string secret_name = 2 [deprecated=true];
    ObjectReference ref = 3;
  }

  message IngressRule {
    string host = 1;
    HTTPIngressRuleValue HTTP = 2;
    TCPIngressRuleValue TCP = 3;
  }

  message HTTPIngressRuleValue {
    int32 port = 1;
    bool no_TLS = 2;
    int32 node_port = 3;
    repeated HTTPIngressPath paths = 4;
  }

  message TCPIngressRuleValue {
    int32 port = 1;
    bool no_TLS = 2;
    int32 node_port = 3;
    IngressBackend backend = 4;
    repeated string ALPN = 5;
  }

  message HTTPIngressPath {
    string path = 1;
    HTTPIngressBackend backend = 2;
  }

  message IngressBackend {
    repeated string host_names = 1;
    string service_name = 2;
    int32 service_port = 3;
    repeated string backend_rule = 4;
  }

  message AuthOption {
    BasicAuth basic = 1;
    TLSAuth tls = 2;
  }

  message BasicAuth {
    string secret_name = 1;
    string realm = 2;
  }

  message TLSAuth {
    string secret_name = 1;
    string verify_client = 2;
    map<string, string> headers = 3;
    string error_page = 4;
  }
}

message KubemonAgentSpec {
  string agent = 1;
  KubemonPrometheusSpec prometheus = 2;
}

message KubemonPrometheusSpec {
  int32 port = 1;
  string namespace = 2;
  map<string, string> labels = 3;
  string intervals = 4;
}

message Toleration {
  string key = 1;
  string operator = 2;
  string value = 3;
  string effect = 4;
  int64 toleration_seconds = 5;
}

message Affinity {
  NodeAffinity node_affinity = 1;
  PodAffinity pod_affinity = 2;
  PodAntiAffinity pod_anti_affinity = 3;
}

message NodeAffinity {
  NodeSelector required_during_scheduling_ignored_during_execution = 1;
  repeated PreferredSchedulingTerm preferred_during_scheduling_ignored_during_execution = 2;
}

message PreferredSchedulingTerm {
  int32 weight = 1;
  NodeSelectorTerm preference = 2;
}

message NodeSelector {
  repeated NodeSelectorTerm node_selector_terms = 1;
}

message NodeSelectorTerm {
  repeated NodeSelectorRequirement match_expressions = 1;
}

message NodeSelectorRequirement {
  string key = 1;
  string operator = 2;
  repeated string values = 3;
}

message PodAffinity {
  repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1;
  repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2;
}

message PodAffinityTerm {
  LabelSelector label_selector = 1;
  repeated string namespaces = 2;
  string topology_key = 3;
}

message LabelSelector {
  map<string, string> match_labels = 1;
  repeated LabelSelectorRequirement match_expressions = 2;
}

message LabelSelectorRequirement {
  string key = 1;
  string operator = 2;
  repeated string values = 3;
}

message WeightedPodAffinityTerm {
  int32 weight = 1;
  PodAffinityTerm pod_affinity_term = 2;
}

message PodAntiAffinity {
  repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1;
  repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2;
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
message LocalObjectReference {
  // Name of the referent.
  // More info: http://kubernetes.io/docs/user-guide/identifiers#names
  // TODO: Add other useful fields. apiVersion, kind, uid?
  // +optional
  string name = 1;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  string value = 2;

  // Source for the environment variable's value. Cannot be used if value is not empty.
  // +optional
  EnvVarSource value_from = 3;
}

// EnvVarSource represents a source for the value of an EnvVar.
message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
  // spec.nodeName, spec.serviceAccountName, status.podIP.
  // +optional
  ObjectFieldSelector field_ref = 1;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  ResourceFieldSelector resource_field_ref = 2;

  // Selects a key of a ConfigMap.
  // +optional
  ConfigMapKeySelector config_map_key_ref = 3;

  // Selects a key of a secret in the pod's namespace
  // +optional
  SecretKeySelector secret_key_ref = 4;
}

// ObjectFieldSelector selects an APIVersioned field of an object.
message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  // +optional
  string api_version = 1;

  // Path of the field to select in the specified API version.
  string field_path = 2;
}

// ResourceFieldSelector represents container resources (cpu, memory) and their output format
message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  // +optional
  string container_name = 1;

  // Required: resource to select
  string resource = 2;

  // Specifies the output format of the exposed resources, defaults to "1"
  // +optional
  string divisor = 3;
}

// Selects a key from a ConfigMap.
message ConfigMapKeySelector {
  // The ConfigMap to select from.
  ObjectReference local_object_reference = 1;

  // The key to select.
  string key = 2;
}

// SecretKeySelector selects a key of a Secret.
message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  ObjectReference local_object_reference = 1;

  // The key of the secret to select from.  Must be a valid secret key.
  string key = 2;
}